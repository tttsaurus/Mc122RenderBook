| **Stage / Feature**    | **Fixed-Function Pipeline**                                                                                   | **Programmable Pipeline**                                                                                                      |
| ---------------------- | ------------------------------------------------------------------------------------------------------------- |--------------------------------------------------------------------------------------------------------------------------------|
| **Vertex Processing**  | Handled by OpenGL’s internal vertex transformation engine using `glModelViewMatrix` and `glProjectionMatrix`. | Handled by the **Vertex Shader**. You write GLSL code to transform vertices using custom matrices passed as uniforms.          |
| **Matrix Management**  | Managed via OpenGL state stack: `glMatrixMode()`, `glPushMatrix()`, `glPopMatrix()`, `glLoadIdentity()`.      | You manage your own matrices (model, view, projection, etc.) and pass them manually to the shader as `uniform mat4`.           |
| **Lighting Model**     | Built-in Phong-like lighting: `glLight*()`, `glMaterial*()`, `glEnable(GL_LIGHTING)`, etc.                    | Fully programmable. Lighting is implemented manually in shaders (Phong, Blinn-Phong, PBR, etc.). No fixed lights exist.        |
| **Coloring**           | Per-vertex coloring with `glColor*()`, interpolated across primitives.                                        | Color data is passed via vertex attributes and interpolated by the rasterizer. You control final color in the fragment shader. |
| **Normals**            | Used with built-in lighting; automatically normalized if `glEnable(GL_NORMALIZE)` was set.                    | You handle normals as vertex attributes. Normalization, transformations, and calculations are done manually in shader.         |
| **Texture Mapping**    | Enabled via `glEnable(GL_TEXTURE_2D)`, configured with `glTexCoord*()` and `glTexEnv*()`.                     | You pass texture coordinates as vertex attributes and manually sample textures using `texture()` in the fragment shader.       |
| **Fog**                | Enabled with `glEnable(GL_FOG)` and controlled via fog parameters (`glFog*`).                                 | Implemented manually in the fragment shader. You compute fog factor and blend colors as desired.                               |
| **Clipping & Culling** | Controlled by fixed states like `glEnable(GL_CULL_FACE)`, `glClipPlane()`.                                    | Still partially handled by fixed-function, but you can do custom clipping logic in the vertex shader (or use discard).         |
| **Alpha Testing**      | Controlled by `glEnable(GL_ALPHA_TEST)` and `glAlphaFunc()`.                                                  | Deprecated. You implement alpha test logic in the fragment shader using `discard`.                                             |
| **Depth Testing**      | Controlled by `glEnable(GL_DEPTH_TEST)` and `glDepthFunc()`.                                                  | Still fixed-function, but combined with programmable output depth via `gl_FragDepth`.                                          |
| **Fixed Attributes**   | Position via `glVertex*()`, color via `glColor*()`, normal via `glNormal*()`, etc.                            | Generic vertex attributes via `glVertexAttrib*()` and bound to shader variables (`in`, `out`).                                 |
| **Shading Mode**       | `glShadeModel(GL_SMOOTH)` vs `GL_FLAT`.                                                                       | Interpolation behavior is programmable. Flat/smooth shading controlled with `flat` qualifier or custom interpolation.          |
| **Multi-Texturing**    | Complex and state-heavy with `glActiveTexture()`, `glTexEnvi()`, `glTexGen*()`.                               | Easy with GLSL samplers; you pass multiple textures and control their blending in shaders.                                     |
| **Per-Pixel Effects**  | Very limited. Lighting and color mostly per-vertex.                                                           | Full per-pixel control in fragment shader: lighting, shadows, PBR, fog, effects, etc.                                          |
| **Post-Processing**    | Nearly impossible or super hacky (rendering to texture via extensions).                                       | Simple with FrameBuffers; post-processing handled in full-screen quad passes with custom shaders.                        |
| **Programmability**    | None. You're limited to enabling/disabling features.                                                          | Full control of the pipeline. You define the behavior of each stage in shader code.                                            |
| **GLSL Shader Stages** | Not available.                                                                                                | You use multiple shader stages: Vertex, Fragment, Geometry, Tessellation Control/Evaluation, Compute.                          |
| **GPU Utilization**    | Poor for complex scenes. You rely on generic GPU-side behavior.                                               | Efficient. You tailor computation to your needs, optimize memory access, and offload CPU.                                      |
| **Debuggability**      | Debugging is opaque; errors are often state-based and cryptic.                                                | Clearer debugging with well-defined shader code. Modern tools support shader introspection and debugging.                      |

## Summary
- Fixed-function pipeline is state-machine driven — you're configuring a black box.
- Programmable pipeline is shader-driven — you're writing the black box yourself.
